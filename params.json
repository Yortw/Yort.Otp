{
  "name": "Yort.otp",
  "tagline": "A portable .Net class library for creating onetime passwords (based on rfc4226 - https://tools.ietf.org/html/rfc4226 and rfc6238 - https://tools.ietf.org/html/rfc6238)",
  "body": "# Yort.Otp\r\nA portable .Net class library for creating onetime passwords (based on [[rfc4226](https://tools.ietf.org/html/rfc4226)] and [[rfc6238](https://tools.ietf.org/html/rfc6238)]).\r\nThese are the sorts of authentication codes used by Google/Microsoft/Facebook/Amazon etc. for second factor authentication.\r\n\r\n[![GitHub license](https://img.shields.io/github/license/mashape/apistatus.svg)](https://github.com/Yortw/Yort.Otp/blob/master/LICENSE.md) \r\n\r\n## Supported Platforms\r\nCurrently;\r\n\r\n* .Net Framework 4.0\r\n* Windows Phone Silverlight (8.1+) \r\n* Xamarin.iOS\r\n* Xamarin.Android \r\n* WinRT (Windows Store Apps 8.1)\r\n* UWP 10+ (Windows 10 Universal Programs)\r\n\r\n## Build Status\r\n[![Build status](https://ci.appveyor.com/api/projects/status/e8116lsaf7oeb74d?svg=true)](https://ci.appveyor.com/project/Yortw/yort-otp)\r\n\r\n## Available on Nuget\r\n\r\n```powershell\r\n    PM> Install-Package Yort.Otp\r\n```\r\n\r\n[![NuGet Badge](https://buildstats.info/nuget/Yort.Otp)](https://www.nuget.org/packages/Yort.Otp/)\r\n\r\n## Samples\r\nIf you're implementing this on a server you should really read and understand the RFC specifications (linked above). There are sever specific issues around managing out of sync counters or client/server times that need to be understood.\r\n\r\nHere are some quick start samples;\r\n\r\n```c#\r\npublic void Main(string[] args)\r\n{\r\n\t// Generate a \"time based\" password from the current time (retrieved via DateTime.UtcNow), \r\n\t// using the ASCII secret in the sample section of https://tools.ietf.org/html/rfc6238.\r\n\t// This uses a default interval of 30 seconds (maximum length of time the password is value for).\r\n\tusing (var passwordGenerator = new TimeBasedPasswordGenerator(false, OnetimePasswordSecret.FromAscii(\"12345678901234567890\")))\r\n\t{\r\n\t\tSystem.Diagnostics.Debug.WriteLine($\"Password: {passwordGenerator.GeneratedPassword} valid until {passwordGenerator.ValidUntilUtc.ToLocalTime()}\");\r\n\t}\r\n}\r\n```\r\n\r\n\r\n```c#\r\npublic void Main(string[] args)\r\n{\r\n\t// Generate a \"counter based\" one time password from a counter value of 10, \r\n\t// using the ASCII secret in the sample section of https://tools.ietf.org/html/rfc6238\r\n    // The counter should be incremented on each *successful* login, and stored between sessions. See the RFC spec for details.\r\n\tusing (var passwordGenerator = new CounterBasedPasswordGenerator(false, OnetimePasswordSecret.FromAscii(\"12345678901234567890\")))\r\n\t{\r\n\t\tpasswordGenerator.Counter = 10;\r\n\t\tSystem.Diagnostics.Debug.WriteLine(\"Password: \" + passwordGenerator.GeneratedPassword);\r\n\t}\r\n}\r\n```\r\n\r\nIf you're going to generate passwords for many different secrets but using an otherwise consistent configuration, factories can make that easier/more concise;\r\n\r\n```c#\r\n// Counter based factory sample\r\n//During startup, obtain and keep a reference to a factory\r\n_OtpFactory = OnetimePasswordGeneratorFactory.CreateFactory(true, new Sha512HashAlgorithm(), 8);\r\n\r\n//When you want to generate a password...\r\nusing (var passwordGenerator = _OtpFactory.CreateNewPasswordGenerator(OnetimePasswordSecret.FromAscii(\"12345678901234567890\"), 10))\r\n{\r\n\tSystem.Diagnostics.Debug.WriteLine($\"Password: {passwordGenerator.GeneratedPassword}\");\r\n}\r\n\r\n// Time based factory sample\r\n//During startup, obtain and keep a reference to a factory\r\n_OtpFactory = OnetimePasswordGeneratorFactory.CreateFactory(true, new Sha512HashAlgorithm(), 8, TimeSpan.FromMinutes(1));\r\n\r\n//When you want to generate a password...\r\nusing (var passwordGenerator = _OtpFactory.CreateNewPasswordGenerator(OnetimePasswordSecret.FromAscii(\"12345678901234567890\")))\r\n{\r\n\tSystem.Diagnostics.Debug.WriteLine($\"Password: {passwordGenerator.GeneratedPassword} valid until {passwordGenerator.ValidUntilUtc.ToLocalTime()}\");\r\n}\r\n```\r\n\r\nThis library *doesn't* generate QR codes, but it can generate the OTP uri to be turned into a QR code for configuring authenticator apps;\r\n\r\n```c#\r\nvar configureAuthenticatorUri =\tOnetimePasswordGeneratorFactory.GetOtpUrl(\"account name or identifier\", \"SHA1\", 8, OnetimePasswordSecret.FromAscii(\"12345678901234567890\"), TimeSpan.FromMinutes(1));\r\n```\r\n\r\nLikewise, if given an OTP uri it can configure a password generator appropriately. This also returns the secret and account name, so they can be stored if required.\r\n\r\n```c#\r\nstring label = null;\r\nbyte[] secret = null;\r\nvar passwordGenerator = OnetimePasswordGeneratorFactory.FromOtpUrl(configureAuthenticatorUri, out label, out secret);\r\n```\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}